// Generated by CoffeeScript 1.12.6
(function() {
  var Packer, Path, cfg, cfgFromArgs, error, getVersion, packer, pathForFlag, printHelp;

  Path = require('path');

  Packer = require('./packer');

  error = null;

  cfg = {
    watch: false,
    bundles: [],
    base: process.cwd(),
    useBabel: false,
    useUglify: false,
    loaderPrefix: 'es6-promise!',
    chunks: './js/chunk_',
    fffMaps: false,
    externalMaps: false
  };

  ({
    getVersion: function() {}
  });

  getVersion = function() {
    var p;
    p = require(Path.resolve(__dirname, '../package.json'));
    return p.version;
  };

  printHelp = function() {
    console.log("\nwerkzeug-packer can be configured using the following flags:\n\n-p  --pack          [file] [file?]  Specify the input file and optional an output file.\n                                    If the output file is omitted, the input file's name is used\n                                    with a 'pack' inserted before the extension:\n                                    e.g.: main.js -> main.pack.js\n                                    Can be used multiple times for each module to bundle.\n-w  --watch                         Start watching and repack on changes.\n-bp --base-path     [file]          Specify a base path to resolve relative files used with -p flag.\n-ub --use-babel     [bool?]         To disable babel enter false. The default is true.\n-uu --use-uglify    [bool?]         To uglify input sources enter true. The default is false.\n-im --inline-maps   [bool?]         To inline sources in maps enter true. The default is false.\n-em --external-maps [bool?]         To include external maps enter true. The default is false.\n-cp --chunk-prefix  [path]          Enter a path and/or a file prefix for all packed chunks.\n                                    The default is './js/chunk_'.\n-lp --loader-prefix [string]        Enter a string to prifix required path's for chunk loading.\n                                    The default is 'es6-promise!'.\n-ne --node-env      [string]        Enter a value to set in window.process.env.NODE_ENV.\n                                    The default is 'development'.\n-v  --version                       Prints the version (" + (getVersion()) + ").\n-h  --help                          Prints this help.\n");
    return null;
  };

  pathForFlag = function(path, flag, name) {
    if (/^-\w$|^-\w\w$/.test(path)) {
      error = name + ' expected behind ' + flag + ' flag. Got another flag: ' + path;
      path = null;
    } else if (!path || !path.length) {
      error = name + ' expected behind ' + flag + ' flag.';
      path = null;
    }
    return path;
  };

  cfgFromArgs = function() {
    var arg, args, basePath, inPath, index, outPath, value;
    args = process.argv.slice(2);
    if (args.length === 0) {
      args = ['-h'];
    }
    index = 0;
    while (index < args.length) {
      switch (arg = args[index]) {
        case '-p' || '--pack':
          inPath = pathForFlag(args[index + 1], arg, 'Input path');
          if (!error) {
            if (!error) {
              outPath = pathForFlag(args[index + 2], arg, 'Output path');
            }
            if (error) {
              outPath = inPath.replace(/\.js$/, '.pack.js');
              error = null;
              index = index + 2;
              cfg.bundles.push({
                "in": inPath,
                out: outPath
              });
            } else {
              index = index + 3;
              cfg.bundles.push({
                "in": inPath,
                out: outPath
              });
            }
          }
          break;
        case '-w' || '--watch':
          cfg.watch = true;
          ++index;
          break;
        case '-h' || '--help':
          if (args.length > 1) {
            error = '-h or --help must be used as single flag';
          } else {
            printHelp();
          }
          ++index;
          break;
        case '-v' || '--version':
          if (args.length > 1) {
            error = '-v or --version must be used as single flag';
          } else {
            console.log(getVersion());
          }
          ++index;
          break;
        case '-bp' || '--base-path':
          basePath = pathForFlag(args[index + 1], arg, 'Base path');
          if (!error) {
            if (Path.isAbsolute(basePath)) {
              cfg.base = basePath;
            } else {
              cfg.base = Path.resolve(process.cwd(), basePath);
            }
            index = index + 2;
          }
          break;
        case '-ub' || '--use-babel':
          cfg.useBabel = true;
          ++index;
          break;
        case '-uu' || '--use-uglify':
          cfg.useUglify = true;
          ++index;
          break;
        case '-im' || '--inline-maps':
          cfg.fffMaps = true;
          ++index;
          break;
        case '-em' || '--external-maps':
          cfg.externalMaps = true;
          ++index;
          break;
        case '-lp' || '--loader-prefix':
          value = args[index + 1];
          if (!value) {
            error = 'Prefix expected behind ' + arg + ' flag.';
          }
          if (/^-\w$/.test(value)) {
            error = 'Prefix expected behind ' + arg + ' flag. Got another flag: ' + value;
          } else {
            cfg.loaderPrefix = value;
            index = index + 2;
          }
          break;
        case '-cp' || '--chunk-prefix':
          value = args[index + 1];
          if (!value) {
            error = 'Prefix expected behind ' + arg + ' flag.';
          }
          if (/^-\w$/.test(value)) {
            error = 'Prefix expected behind ' + arg + ' flag. Got another flag: ' + value;
          } else {
            cfg.chunks = value;
            index = index + 2;
          }
          break;
        case '-ne' || '--node-env':
          value = args[index + 1];
          if (!value) {
            error = 'Value expected behind ' + arg + ' flag.';
          }
          if (/^-\w$/.test(value)) {
            error = 'Value expected behind ' + arg + ' flag. Got another flag: ' + value;
          } else {
            cfg.NODE_ENV = value;
            index = index + 2;
          }
          break;
        default:
          error = 'Unknown or unexpected argument: ' + arg;
      }
      if (error) {
        return;
      }
    }
    return null;
  };

  cfgFromArgs();

  if (error) {
    console.log('Error: ', error);
  } else {
    packer = new Packer(cfg);
  }

}).call(this);
